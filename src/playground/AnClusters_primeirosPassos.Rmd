---
title: "Exemplos de Análise de Clusters"
output: html_notebook
---

#Base de Dados

```{r}
# Designar work directory.
setwd("C:/Users/rodto/OneDrive/04 Profissional/03 Letivas/04 FGV/02 MBA BA BigData/04 Disciplinas/08 Matrizes e Clusters/04 An Clusters/")
getwd()
```

```{r}
# Ler os dados do arquivo Excel no work directory.
#install.packages("readxl")
library(readxl)
ATIBAIA <- read_xlsx("ATIBAIA.xlsx", sheet = "ATIBAIA", col_names = TRUE)
```

#Estudo e Avaliação dos Dados

```{r}
# Mapear os tipos dos dados das colunas da tabela importada.
sapply(ATIBAIA, class)
# Sumarizar as características univariadas dos dados da tabela importada.
summary(ATIBAIA)
# Repare que as variáveis biling, estac e ti estão sendo erroneamente sendo tratadas como numéricas, quando na verdade são fatores.
```

```{r}
# Mudar o tipo das variáveis biling, estac e ti para factor.
ATIBAIA$biling=as.factor(ATIBAIA$biling)
ATIBAIA$estac=as.factor(ATIBAIA$estac)
ATIBAIA$ti=as.factor(ATIBAIA$ti)
# Refazer a sumarização das características univariadas dos dados da tabela importada, agora com os tipos das colunas corrigidos.
summary(ATIBAIA)
```

```{r}
# Selecionar somente as variáveis drivers de clustering (filial não é porque é apenas o nome da filial, aval_global não é porque é uma composição das outras variáveis, e idade também não é porque não é um fator caracterizador relevante).
ATIBAIA_drivers = ATIBAIA[ , -c(1,2,9)]
```

#Algoritmos Nativos do R (patote 'stats')

##An. de Clusters POR PARTIÇÃO: K-Means

```{r}
# Preparando dados, transformando tudo para tipo numérico e colocando as colunas em escala.
ATIBAIA_drivers_num <- ATIBAIA_drivers
ATIBAIA_drivers_num$biling = as.numeric(ATIBAIA_drivers_num$biling)
ATIBAIA_drivers_num$estac = as.numeric(ATIBAIA_drivers_num$estac)
ATIBAIA_drivers_num$ti = as.numeric(ATIBAIA_drivers_num$ti)

ATIBAIA_drivers_num_z <- as.data.frame(lapply(ATIBAIA_drivers_num, scale))
```

```{r}
# Calculando a correlação entre as variáveis. Deve-se tomar o cuidado de que não hajam grandes correlações entre as variáveis, pois estaríamos considerando a mesma informação repetidas vezes, aumentando o "peso" daquela informação na formação dos clusters.
cor(ATIBAIA_drivers_num_z)
# Ok, não existem grandes correlações.
```

```{r}
# A função mais utilizada para operacionalizar o K-Means é a kmeans, nativa do R vinculada à biblioteca stats, também nativa do R. Por ser uma biblioteca nativa, não há necessidade de carregar a biblioteca pois a mesma já é naturalmete carregada.
KMeans_clustering_k3 <- kmeans(ATIBAIA_drivers_num_z, 3, nstart = 20)
KMeans_clustering_k3
```

```{r}
# Vetor de clusters finais.
KMeans_clustering_k3$cluster
```

```{r}
# Centróides dos clusters.
KMeans_clustering_k3$centers
```

```{r}
# Soma total de distâncias quadráticas (Total Sum of Squares).
KMeans_clustering_k3$totss
```

```{r}
# Soma de distâncias quadráticas internas a cada cluster (Whithin Sum of Squares).
KMeans_clustering_k3$withinss
```

```{r}
# Soma total de distâncias quadráticas internas a cada cluster (Total Whithin Sum of Squares).
KMeans_clustering_k3$tot.withinss
```

```{r}
# Soma total de distâncias quadráticas entre observações de clusters diferentes (Between Sum of Squares).
KMeans_clustering_k3$betweenss
```

```{r}
# Tamanho dos clusters.
KMeans_clustering_k3$size
```

```{r}
# Iteraçoes para que se chegasse ao resultado final.
KMeans_clustering_k3$iter
```

```{r}
# Indicação de se houve alguma falha na execução do algoritmo.
KMeans_clustering_k3$ifault
```

```{r}
# Carregar pacote fpc (Flexible Procedures for Clustering), que possui uma série de funções para análise de clusters.
library(fpc)
# Utilizar a função plotcluster do pacote fpc, que imprime o gráfico espacial nas duas componentes principais mais relevantes.
plotcluster(ATIBAIA_drivers_num_z, KMeans_clustering_k3$cluster)
# Nota-se que os grupos estão bem separados, o que é um bom sinal.
```

```{r}
#install.packages("factoextra")
library(factoextra)
fviz_cluster(list(data = ATIBAIA_drivers_num_z, cluster = KMeans_clustering_k3$cluster),  show.clust.cent = T)

```

```{r}
# Calcular a matriz de distâncias.
?dist
ATIBAIA_drivers_num_z_dist <- dist(ATIBAIA_drivers_num_z, method = "euclidean")
ATIBAIA_drivers_num_z_dist
```

```{r}
# Utilizar a função cluster.stats da library fpc para uma lista maior de métricas da solução de clusters encontrada.
library(fpc)
?cluster.stats
cluster.stats(ATIBAIA_drivers_num_z_dist, KMeans_clustering_k3$cluster)
```

# Algoritmos do Pacote 'clusters'

```{r}
# O pacote clusters tem uma série de funções (daisy, que calcula a matriz de distância por Gower) e algoritmos (AGNES e DIANA, por exemplo) de análise de clusters.
#install.packages("cluster")
library(cluster)

# Padronizar as variáveis e calcular a matriz de distancias por métrica de Gower.
md = daisy(ATIBAIA_drivers)
```

##An. de Clusters POR PARTIÇÃO: K-Medoid

```{r}
# Usa-se a função pam (Partitioning Around Medoids) do pacote cluster.
library(cluster)
KMedoid_clustering <- pam(md, k = 3, diss = TRUE)
KMedoid_clustering
```

```{r}
# A entrada para a função pam pode ser tanto a matriz de distâncias (caso anterior), quanto a matriz de observações (x) por variáveis (y) (como no caso abaixo). Deve-se alterar o parâmetro diss para FALSE).
library(cluster)
KMedoid_clustering <- pam(ATIBAIA_drivers_num_z, k = 3, diss = FALSE)
KMedoid_clustering
```

```{r}
# Imprimir os medoids finais.
KMedoid_clustering$medoids
```

```{r}
# Imprimir os ids dos medoids finais.
KMedoid_clustering$id.med
```

```{r}
# Vetor de clusters de cada observação.
KMedoid_clustering$clustering
```

```{r}
# Função objetivo do método de construção e swap (algoritmos de otimização que são executados pré K-Medoid para que a escolha inicial de medoids seja melhorada.
KMedoid_clustering$objective
```

```{r}
# Indicação se algum dos clusters pode ser classificado como isolado (quando o diâmetro é maior que a separação de clusters ou outras relações desfavoráveis de métricas).
KMedoid_clustering$isolation
```

```{r}
# Informações de distância.
KMedoid_clustering$clusinfo
```

```{r}
# Informação de silhouette.
KMedoid_clustering$silinfo
```

```{r}
# Matriz de distâncias de distâncias.
KMedoid_clustering$diss
```

```{r}
# Chamada de função originadora.
KMedoid_clustering$call
```

```{r}
# Jeito mais fácil de imprimir o gráfico de silhouette.
plot(KMedoid_clustering)
```

```{r}
# Outra maneira de obter dados de silhouette e imprimir o gráfico correspondente.
library(cluster)
sil=silhouette(KMedoid_clustering, md)
head(sil[,1:3])
plot(sil, cex=.6, border = 1, col = "lightblue")
```

```{r}
# Utilizar a função cluster.stats da library fpc para uma lista maior de métricas da solução de clusters encontrada.
library(fpc)
?cluster.stats
cluster.stats(ATIBAIA_drivers_num_z_dist, KMedoid_clustering$cluster)
```

##An. de Clusters HIERÁRQUICOS: AGNES

```{r}
# Usa-se a função agnes do pacote cluster.
library(cluster)
agnes_clustering <- agnes(md, diss = TRUE, method = "complete")
agnes_clustering
```

```{r}
# Imprime a ordem das observações, guardadas para facilitar a impressão do dendograma.
agnes_clustering$order
```

```{r}
# Imprime a altura de aglomeração para as observações conforme vão acontecendo.
agnes_clustering$height
```

```{r}
agnes_clustering$ac
```

```{r}
agnes_clustering$merge
```

```{r}
agnes_clustering$diss
```

```{r}
agnes_clustering$call
```

```{r}
agnes_clustering$method
```

```{r}
plot(agnes_clustering)
```

```{r}
agnes_clustering_k3 <- cutree(agnes_clustering, k = 3)
agnes_clustering_k3
```

```{r}
#install.packages("factoextra")
library(factoextra)
fviz_dend(agnes_clustering, k=3)
```

```{r}
#install.packages("factoextra")
library(factoextra)
fviz_cluster(list(data = ATIBAIA_drivers_num_z, cluster = agnes_clustering_k3),  show.clust.cent = F)
```

```{r}
# Utilizar a função cluster.stats da library fpc para uma lista maior de métricas da solução de clusters encontrada.
library(fpc)
?cluster.stats
cluster.stats(ATIBAIA_drivers_num_z_dist, agnes_clustering_k3)
```

##An. de Clusters HIERÁRQUICOS: DIANA

```{r}
library(cluster)
diana_clustering <- diana(md, diss = TRUE)
diana_clustering
```

```{r}
# Imprime a ordem das observações, guardadas para facilitar a impressão do dendograma.
diana_clustering$order
```

```{r}
# Imprime a altura de aglomeração para as observações conforme vão acontecendo.
diana_clustering$height
```

```{r}
# Imprime o coeficiente de 
diana_clustering$dc
```

```{r}
diana_clustering$merge
```

```{r}
diana_clustering$diss
```

```{r}
plot(diana_clustering)
```

```{r}
diana_clustering_k3 <- cutree(diana_clustering, k = 3)
diana_clustering_k3
```

```{r}
#install.packages("factoextra")
library(factoextra)
fviz_dend(agnes_clustering, k=3)
```

```{r}
#install.packages("factoextra")
library(factoextra)
fviz_cluster(list(data = ATIBAIA_drivers_num_z, cluster = agnes_clustering_k3),  show.clust.cent = F)
```

```{r}
# Utilizar a função cluster.stats da library fpc para uma lista maior de métricas da solução de clusters encontrada.
library(fpc)
?cluster.stats
cluster.stats(ATIBAIA_drivers_num_z_dist, diana_clustering_k3)
```